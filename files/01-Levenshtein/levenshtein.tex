\documentclass[paper=a4, fontsize=11pt]{article}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amsthm, hyperref}
\setlength\parindent{0pt} 

\title{	
\huge Programowanie dynamiczne na grafach
}

\date{\normalsize\today}

\begin{document}

\maketitle

\newtheorem{mydef}{Definicja}
\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemma}{Lemat}

\section{Definicje}
\begin{mydef}[Rodzina zbiorów]
\begin{gather*}
\mathcal{A} = \{ A_i : A_i \subseteq X, i \in \mathbb{N} \} \\
\end{gather*}
Będziemy używać jedynie skończonych rodzin.
\end{mydef}
\begin{mydef}[Suma uogoólniona] 
\begin{gather*}
\bigcup \mathcal{A} = \bigcup_i A_i = \{ x \in X : \exists_i x \in A_i \}
\end{gather*}
\end{mydef}

\begin{theorem}[Wzór jawny dla ciągu Fibonacciego]
\begin{gather*}
F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2} \\
F_n = \frac{1}{\sqrt{5}}(\frac{1 + \sqrt{5}}{2})^n - \frac{1}{\sqrt{5}}(\frac{1 - \sqrt{5}}{2})^n
\end{gather*}
\end{theorem}
\begin{proof}
n = 0, n = 1 sprawdzamy ręcznie. \\
Pokazujemy, że $x^2 = x + 1$, gdy $x \in \{\frac{1 + \sqrt{5}}{2}, \frac{1 - \sqrt{5}}{2}\}$ \\
Niech $x_1 = \frac{1 + \sqrt{5}}{2}, x_2 = \frac{1 - \sqrt{5}}{2}, p = \frac{1}{\sqrt{5}}$

\begin{equation*}
\begin{split}
F_n &= F_{n-1} + F_{n-2} = px_1^{n-1} - px_2^{n-1} + px_1^{n-2} - px_2^{n-2} \\
&= px_1^{n-2}(1 + x_1) + px_2^{n-2}(1 + x_2) \\
&= px_1^n + px_2^n
\end{split}
\end{equation*}
\end{proof}

\begin{mydef} [Programowanie dynamiczne na acyklicznych, skończonych grafach skierowanych]
Tworzenie algorytmu przebiega w następujący sposób. \\

Najpierw definiujemy zbiór X, pewną własność C oraz zbiory poprzedników $b(x)$ wszystkich elementów zbioru X. Każdy element x ma własność C lub jej nie ma.\\

Definiujemy również zbiór poprzedników danego zbioru jako.
\begin{displaymath}
B(X) = \bigcup_{x \in X} b(x)
\end{displaymath}

Dzielimy graf na warstwy \textbf{(sortowaniem topologicznym)}, zaczynając od wierzchołków do których nie wchodzi żadna krawędź (warstwa $W_0$). Wierzchołek v należy do warstwy $W_k$ wtedy i tylko wtedy, gdy jego \textbf{najdłuższa} ścieżka do wierzchołka z warstwy $W_0$ ma długość k. \\

Zakładamy tutaj, że wszyscy poprzednicy należą do poprzednich warstw. (Graf skierowany acykliczny.)
\begin{displaymath}
\forall_k \forall_{w \in W_k} b(w) \subseteq \bigcup_{i < k} A_i
\end{displaymath}

Naszym celem jest pokazanie, że jeśli dla wszystkich wcześniejszych wierzchołków zachodzi własność C i potrafimy na tej podstawie udowodnić własność C dla kolejnych wierzchołków, to własność C zachodzi dla wszystkich wierzchołków.
Dowodzimy to w następujący sposób.


\begin{enumerate}
\item Podstawa indukcji
\begin{displaymath}
\forall_{x \in W_{0}} C(x)
\end{displaymath} 
\item Krok indukcyjny
\begin{displaymath}
(\forall_{w \in W_n} (\forall_{p \in b(w)} C(p))) \implies C(w)
\end{displaymath}
\end{enumerate}

Wówczas zachodzi:
\begin{displaymath}
(\forall_{n \in \mathbb{N}}( \forall_{w \in W_n} (\forall_{p \in b(w)} C(p)) \implies C(w))) \implies \forall_{x \in X} C(x)
\end{displaymath}

Uwagi!
\begin{itemize}
\item Graf nie musi być spójny.
\end{itemize}
\end{mydef}

\begin{mydef}
\begin{equation}
[x = y] = 
\begin{cases}
1, & x = y \\
0, & x \neq y
\end{cases}
\end{equation}
\end{mydef}

\begin{mydef}[Odległość Levenshteina]
Mamy dwa ciągi znaków $(a_1, a_2, \dots a_{n})$ oraz $(b_1, b_2, \dots b_{m})$ długości odpowiednio n i m. Należy znaleźć minimalną liczbę operacji potrzebnych do przekształcenia ciągu a w ciąg b.

Dopuszczalne są następujące operacje:
\begin{itemize}
\item Wstaw dowolny znak c w dowolne miejsce ciągu a.
\item Usuń dowolny znak c z ciągu a.
\item Zamień dowolny znak c ciągu a na inny znak.
\end{itemize}

Dla ustalenia uwagi oznaczmy, tą liczbę przez L(a,b).
\begin{lemma} $L(a, b) \ge max(n, m) - min(n, m) = |n - m|$ \\ 
Jeśli dwa ciągi mają różne długości to zawsze musimy przedłużyć lub skrócić ciąg [a] o różnicę ich długości.
\end{lemma}
\begin{lemma} $L(a,b) \le max(n, m)$ \\
Możemy po prostu wymieniać wszystkie znaki po kolei.
\end{lemma}

Z powyższych lematów możemy wywnioskować kolejne.
\begin{lemma} $ n = 0 \implies L(a, b) = m$ 
\end{lemma}
\begin{lemma} $ m = 0 \implies L(a, b) = n$
\end{lemma}

\end{mydef}
\section{Zadanie}
Napisać algorytm obliczający L(a, b) oraz wypisujący ciąg operacji.

\begin{mydef}[Prefiks]
Niech $a[1 \dots i]$ będzie prefikem a długości i.
\end{mydef}
\begin{theorem} 
\begin{gather*}
d(0,0) = 0 \\
d(i, j) = min(d(i, j-1) + 1 , d(i-1, j) + 1, d(i-1, j-1) + [a_i \neq b_j])
\end{gather*}
Wówczas $d(i, j) = L(a[1, \dots, i], b[1, \dots, j])$
\end{theorem}
\begin{proof} Pokażemy to indukcyjnie. \\
Zdefiniujmy kolejne warstwy:
\begin{gather*}
W_0 = \{(0, 0)\} \\
W_k = \{(i, j) : i + j = k \} \\
W_{n+m} = \{(n, m)\} \\
\begin{bmatrix}
0 & 1 & 2 & 3 & \dots & m \\
1 & 2 & 3 & 4 & \dots & m + 1 \\
2 & 3 & 4 & 5 & \dots & m + 2\\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
n & n+1 & n+2 & n+3 & \dots & n+m
\end{bmatrix}
\end{gather*}
\begin{enumerate}
\item Podstawa indukcji (k = 0). \\
Dla pustych ciągów nie trzeba nic robić.
\item Krok indukcyjny
\begin{itemize}
\item k = 1 \\
\begin{gather}
W_1 = \{(0, 1), (1, 0)\} \\
B({W_1}) = B((0,1)) \cup B((1,0)) = \{(0,0) \} = W_0 \subseteq W_0
\end{gather}
\item $k > 1$ \\
\begin{gather*}
\forall_{(i, j) \in W_k} \{(i-1, j), (i, j-1), (i-1, j-1)\} \subseteq W_{k-2} \cup W_{k-1} \\
B(W_k) \subseteq W_{k-2}  \cup W_{k-1}
\end{gather*}

Wybranie wartości minimum to po prostu wybranie odpowiedniego ruchu w danym momencie, takiego dla którego sumaryczny koszt jest najniższy. Sumaryczny koszt obliczamy dynamicznie na podstawie wcześniej obliczonych kosztów.
\end{itemize}

\end{enumerate}

\end{proof}

\section{Zadanie dodatkowe}
Należy rozpatrzyć dwa inne przypadki.
\begin{itemize}
\item Wszystkie operacje mają różne koszty.
\item Nie ma operacji zamiany znaku.
\item Inny podział na warstwy. Pokazać, że istnieje algorytm o złożoności pamięciowej O(max(n,m)).
Tym razem zaczniemy numerację warstw od 1.
\begin{gather*}
W_1 = \{(0,0) \} \\
W_k = \{(i,j) : j(n+1) + i + 1 = k\} \\
W_{(n+1)(m+1)} = \{(n, m) \} \\
W_k = \{(k\mod{(n +1)},\frac{k}{n+1}\} \\
\begin{bmatrix}
1 & n + 2 & 2n + 3 & \dots & m(n + 1) + 1 \\
2 & n + 3 & 2n + 4 & \dots & m(n + 1) + 2 \\
3 & n + 4 & 2n + 5 & \dots & m(n + 1) + 3 \\
4 & n + 5 & 2n + 6 & \dots & m(n + 1) + 4\\
\vdots & \vdots & \vdots & \ddots & \vdots \\
n+1 & 2(n+1) & 3(n+1) & \dots & (m+1)(n+1) 
\end{bmatrix}
\end{gather*}
\end{itemize}

\end{document}
